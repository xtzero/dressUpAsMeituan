{"./":{"url":"./","title":"请读我","keywords":"","body":"下载地址和后台地址 app下载地址 后台地址 源码下载 app源码下载地址 前端源码下载地址 论文的gitbook markdown源文件下载地址 论文说明 这里只有论文内容，论文格式请按相关要求自己调整。 论文直接复制到word中，图片和相关字体大小格式都会保留。 论文目录 # Summary - [请读我](README.md) - ------ - [标题和封皮](md/0.0.md) - [摘要](md/0.1.md) - [目录](md/README.md) - [第1章 需求分析](md/1.md) - [1.1 用户需求分析](md/1.md) - [1.2 需求列表](md/1.md) - [第2章 开发技术及开发工具](md/2.md) - [2.1 技术架构](md/2.md) - [2.2 app端](md/2.md) - [2.3 管理端](md/2.md) - [2.4 后端技术](md/2.md) - [2.5 数据库](md/2.md) - [2.6 域名与服务器](md/2.md) - [2.7 开发工具](md/2.md) - [第3章 产品设计阶段](md/3.md) - [3.1 可行性分析](md/3.md) - [3.2 系统流程设计](md/3.md) - [3.3 系统功能设计](md/3.1.md) - [3.4 用户用例图](md/3.1.md) - [第4章 开发准备与开发前设计]() - [4.1 搭建服务器环境](md/4.1.md) - [4.2 部署框架代码到服务器](md/4.2.md) - [4.3 设置域名解析](md/4.3.md) - [第5章 数据库设计](md/5.md) - [5.1 概念结构设计](md/5.md) - [5.2 逻辑结构设计](md/5.md) - [5.3 数据库的物理实现]() - [第6章 编码开发](md/6.md) - [6.1 后端架构设计](md/6.md) - [6.1.1 框架结构](md/6.md) - [6.1.2 程序入口](md/6.md) - [6.1.3 数据库类](md/6.md) - [6.1.4 参数验证方法](md/6.md) - [6.1.5 模型](md/6.md) - [6.1.6 函数库](md/6.md) - [6.1.7 登录与权限验证机制](md/6.md) - [6.2 后端接口开发](md/6.2.md) - [6.2.1 登录](md/6.2.md) - [6.2.2 店铺 - 列表](md/6.2.md) - [6.2.3 店铺 - 查看店铺详情与物品列表](md/6.2.md) - [6.2.4 订单 - 创建订单](md/6.2.md) - [6.2.5 订单 - 查看订单列表](md/6.2.md) - [6.2.5 用户 - 查看基本信息](md/6.2.md) - [6.2.6 用户 - 修改用户信息](md/6.2.md) - [6.2.7 用户 - 查看全部收货地址](md/6.2.md) - [6.2.8 用户 - 管理收货地址](md/6.2.md) - [6.2.9 后台 - 创建店铺](md/6.2.md) - [6.2.10 后台 - 修改店铺信息](md/6.2.md) - [6.2.11 后台 - 添加物品](md/6.2.md) - [6.2.12 后台 - 删除物品](md/6.2.md) - [6.2.13 后台 - 查看订单列表](md/6.2.md) - [6.2.14 后台 - 查看所有用户列表](md/6.2.md) - [6.2.15 后台 - 修改用户信息](md/6.2.md) - [6.3 app端前端页面与逻辑](md/6.3.md) - [6.3.1 登录与登录凭证保存](md/6.3.md) - [6.3.2 标题和导航](md/6.3.md) - [6.3.3 用户首页和订单列表](md/6.3.md) - [6.3.4 店铺列表](md/6.3.md) - [6.3.5 店铺详情和物品列表](md/6.3.md) - [6.3.6 创建订单](md/6.3.md) - [6.3.7 用户信息修改](md/6.3.md) - [6.3.8 订单详情](md/6.3.md) - [6.3.9 收货地址选择和管理](md/6.3.md) - [6.4 后台管理端前端页面与逻辑](md/6.4.md) - [6.4.1 登录机制](md/6.4.md) - [6.4.2 导航和路由](md/6.4.md) - [6.4.3 订单管理](md/6.4.md) - [6.4.4 店铺管理](md/6.4.md) - [6.4.5 物品管理](md/6.4.md) - [6.4.6 用户管理](md/6.4.md) - [第7章 软件测试](md/7.md) - [7.1 功能测试](md/7.md) - [7.2 可用性测试](md/7.md) - [7.3 测试结果分析](md/7.md) - [结论](md/n1.md) - [参考文献](md/n2.md) - [后记](md/n3.md) "},"md/0.0.html":{"url":"md/0.0.html","title":"标题和封皮","keywords":"","body":"一种基于跨平台开发技术的在线点餐系统 One Kind of Online Ordering System Based On Cross-Platform Development Technology "},"md/0.1.html":{"url":"md/0.1.html","title":"摘要","keywords":"","body":"摘 要 随着互联网的发展，我们身边的商家也纷纷接入了一些互联网平台（例如美团、饿了么等）。这些平台提升了商家的销售效率，也极大地方便了客户与商家间的交流。在“平台”概念成熟之后，美团首次推出了面向每一个商家开放的点餐平台。商家在餐桌上贴二维码，吃饭的人只需要进店扫码即可完成点餐操作，这样既节省了给服务员开支的成本，也大大提升了效率。而后同类产品又继续发展，一些有相关资源的商家有了自家的网店平台。由于是自家投资开发的平台，所以在功能上可以有相对自由又丰富的订制。 本系统基于跨平台开发技术，使用常规的web前端和php后端技术，开发出app客户端和web管理端，组成了一个针对单个商家使用的点餐系统。系统涵盖订单、商家、物品、用户等模块，组成一个完善的点餐+配送闭环。用户在线上完成点单，商家在后台查看订单并进行配送。同时后台提供用户管理功能，商家可以在线下对用户的线上账户进行充值，作为用户的账户储值。 本论文基于此项目，从需求分析、产品设计、功能的编码与实现、系统测试等方面，按照在企业中一个项目的生命周期的顺序进行详细叙述。系统具有科学且严谨的架构，遵循软件工程基本原理，遵循一套详尽的代码格式要求。系统使用前后端分离开发的方式，在最大程度上降低了开发成本与系统复杂性，让一切问题都有迹可循，同时也提高了系统的性能，提高安全性，易于维护和操作。 关键词：跨平台开发技术；点餐系统； Abstract 英文部分是用软件直接翻译的上边的文字 With the development of the Internet, the businessmen around us have also access to some Internet platforms (such as Mei Tuan, hungry, etc.). These platforms improve the sales efficiency of the merchants and greatly facilitate the communication between customers and merchants. After the concept of \"platform\" has matured, the delegation first launched an open ordering platform for every business. Businessmen paste two-dimensional codes on the dining table, and diners only need to enter the shop to scan the codes to complete the ordering operation, which not only saves the cost of waiters, but also greatly improves efficiency. Then similar products continue to develop, and some businesses with relevant resources have their own online store platform. Because it is a platform for self-investment and development, it has relatively free and abundant customization in function. This system is based on cross-platform development technology, using conventional web front-end and PHP back-end technology, develops app client and web management end, and constitutes a ordering system for a single business. The system covers modules such as orders, merchants, goods and users, and forms a perfect ordering + distribution closed-loop. Users complete orders online, and businesses check orders in the background and distribute them. At the same time, the background provides user management function. Businessmen can recharge their online accounts offline as user's account storage value. This paper is based on this project, from the aspects of requirement analysis, product design, function coding and implementation, system testing and so on, according to the order of the life cycle of a project in an enterprise. The system has a scientific and rigorous architecture, follows the basic principles of software engineering, and follows a set of detailed code format requirements. The system uses the way of front-end and back-end separated development, which reduces the development cost and complexity to the greatest extent, makes all problems follow, and improves the system performance, security, easy maintenance and operation. Key words: cross-platform development technology; ordering system; "},"md/1.html":{"url":"md/1.html","title":"第1章 需求分析","keywords":"","body":"第1章 需求分析 1.1 用户需求分析 对于每一个接入了大平台的商家而言，无论是加盟费还是平台抽成，都是商家每年一笔不小的开销。但是平台带来的收益也确实可观。长久地为平台提供佣金，不如一气呵成出资打造一个自家的平台，这样一来既可以满足同样的需求，还可以基于自家店的特点来定制一些特色功能。 本项目搭建了一个将点餐和配送以及用户服务结合为一体的平台，可以为每个单独的商家定制功能。可以满足商家“自私”的需求，同时也能提升店里的运营效率。在功能上，提供最基础的点餐、订单等功能，对商家提供订单后台，可以很方便地管理物品和订单以及用户信息。待投入运营后收集了一定量的数据，还可以进行一定程度的数据分析，拟开发用户喜好推荐等功能。 1.2 需求列表 用户端需求 登录 查看商家 查看物品 选择物品、下单 个人信息管理 收货地址管理 后台端需求 登录 查看用户列表 编辑用户信息 商家管理 物品管理 订单管理 "},"md/2.html":{"url":"md/2.html","title":"第2章 开发技术及开发工具","keywords":"","body":"2 开发技术及开发工具 2.1 技术架构 本项目使用linux系统的服务器，搭建lamp服务器。app前端使用html5+的跨平台技术开发app，后台前端使用vue配合vue-cli脚手架工具，后端使用php开发接口，数据库使用mysql。 2.2 App端 App前端使用html+css+javascript作为开发语言。使用html5+ runtime打包技术，可以轻松将开发的页面打包成近似于原生开发的App，支持双平台。这种技术依赖于Dcloud数字天堂的Hbuilder编辑器和MUI前端框架，借助一套plus的类库来操作系统底层的方法。 2.3 管理端 管理端前端使用Vue.js框架，配合webpack+vue-cli构建工具来进行开发。 Vue.js是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 webpack是基于node.js下npm的打包工具，本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 vue-cli是vue.js在webpack下的一个构建工具，它允许开发者使用一系列的webpack命令来构建一个组件化的vue.js项目，让前端程序更像是要编译的。借助webpack下的bable工具，让打包出来的代码更精简，并兼容全平台。 2.4 后端技术 后端使用php语言开发，前后端使用接口方式通信，后端程序主要是编写接口。本项目使用了为此特别开发的框架，这个框架基于MVC设计思想，但不依附于任何其他的框架。入口文件负责启动程序，每个单独的文件都是一个控制器（Controller），db.php负责数据库驱动，数据库类使用单例模式设计。dbUtil中存放所有数据库逻辑部分。在 Controller 中，每个独立的方法就是一个前端可以使用的独立的接口。 2.5 数据库 本系统使用 MySQL 数据库管理系统作为主要的数据存储数据库。由于后框架封装好了对MySQL的支持得特别好，二者搭配可以发挥更大的优势。 2.6 域名与服务器 本系统运行在搭载了CentOS系统的服务器上，使用yum包管理工具安装apache、mysql、php，组成lamp架构。 域名和服务器都在腾讯云购买。 2.7 开发工具 App端使用HBuilder开发，使用mumu模拟器调试。后台管理端使用Webstorm开发，使用Chrome浏览器调试。后端使用VSCode开发，使用postman进行接口调试。服务器使用windows自带的cmd链接并调试。数据库使用Navicat Mysql的图形化界面来进行开发。 "},"md/3.html":{"url":"md/3.html","title":"第3章 产品设计阶段","keywords":"","body":"第3章 产品设计阶段 3.1 可行性分析 3.1.1 技术可行性 本系统基于web前端和PHP开发技术。前端使用平常的web网页技术，后端则使用时下最流行的PHP服务端编程语言。数据库上使用比较简单且开源易用的MySQL数据库。这一套架构最大程度上降低了开发成本，结合这几种技术进行开发，方案是可行的。 3.1.2 经济可行性 服务器使用腾讯云学生机，10元/月。在服务器上搭建PHP、MySQL等应用，费用与服务器共享。由于前期服务器流量不会很高，最基础的学生机配置足够。经济上可行。 3.2 系统流程设计 3.2.1 App系统流程设计 用户在手机系统点击App图标进入程序，首先会检查登录状态，如果没有登录状态则会跳转到登录页面。登录状态检查会在每次进行http请求时进行，如果发现没有登录状态，都会执行这个动作。 进入主页面后，第一个Tab是“我的”，在这里会看到当前用户的个人信息和最近订单。点击订单会跳转到订单详情，来查看订单中包含的物品以及订单价格。点击个人信息则会跳转到个人信息管理，包括修改昵称、头像、管理收货地址等。 第二个Tab是点餐，首先会查看店铺列表，点击店铺则可以查看该店铺下的物品列表和价格。在这个界面下可以选择要购买的商品，点击下单则会创建订单。在创建订单页面可以确认要购买的商品，确认后选择收货地址，选择下单之后就会进行扣款并正式创建订单。 在个人信息设置页，可以点击“退出登录”来注销登录信息，同时后退到登陆界面。 3.2.2 后台管理系统系统流程设计 商家通过访问网址来打开后台管理系统。进入系统时会检查登录状态，如果没有登录则会跳转到登录，反之则会进入系统。进入系统后会周期性地进行检查登录状态，如果发现登录状态过期，或者是丢失了登录状态，则会跳转会登录页面。左侧导航栏展示了后台管理系统的功能，包括订单管理、物品管理、店铺管理、用户管理。 订单管理中会按创建时间倒序展示全部订单，暂时只有展示功能，后续准备增加订单的编辑、删除等功能。店铺管理中可以查看全部已存在的店铺，并且可以添加新的店铺。对已存在的店铺，可以进行编辑和删除操作。物品管理中可以查看全部已存在的物品，可以增加新的物品，并且可以对已存在的物品进行编辑和删除。用户管理中可以查看全部系统中已存在的用户，对已存在的用户可以进行编辑。暂时没有添加用户的功能，想要添加用户还需要前往数据库中手动添加。 在登录状态下，可以点击右上角的头像，在下拉菜单中随时点击“退出登录”来清除登录信息，并后退到登录界面。 "},"md/3.1.html":{"url":"md/3.1.html","title":"3.3 系统功能设计","keywords":"","body":"3.3 系统功能设计 这一部分将对每的系统功能进行详细设计，并绘制原型图。 这一部分已经包含了原型图设计和 UI 设计。 绘制原型图使用优秀的设计工具 “墨刀 ”。 图1 点餐界面 图2 个人信息修改页面 图3 创建订单页面 图4 钱包页面 3.3.1 登录 进入首页时会检查是否存在登录信息，如果不存在登录信息则会提示用户登录。输入用户名和密码后会显示给用户loading样式，登录后从后端接口获取登录凭证（token）。 3.3.2 首页查看个人信息 登录后进入首页，页面加载完成后会向后端请求个人信息。个人信息包括昵称、头像，用户id、钱包余额。 3.3.3 首页查看订单列表 加载个人信息的同时还会向后端请求获取订单列表，会获取当前用户的全部订单，按创建订单时间倒序排序。后续如果数据量增加，还会加入分页功能。 3.3.4 查看订单详情 点击单个订单可前往订单详情页，在订单详情页可以回去到订单的基本信息（下单人，下单时间，订单地址，订单价格）和订单所包含的物品列表。 3.3.5 查看店铺列表 会显示全部已存在的的店铺列表。如果后续数据量增大，会加入分页功能。 3.3.6 查看店铺详情 点击单个店铺可进入店铺详情页，在详情页可以查看到店铺的详细信息，包括店铺名字、店铺公告等。 3.3.7 查看店铺下物品列表 物品列表和店铺详情同时加载，会显示在同一个页面下。物品列表包含物品的名字、物品简介和物品价格。 3.3.8 选择物品 在物品列表点击物品名称下方加减号可以选择要购买的物品数量。 3.3.9 下单 选好物品后点击下单可以预览订单，在预览页面可以在预先配置好的地址列表中选择一个收货地址。下单页面还会显示选择好的物品列表和对应的物品数量。点击下单按钮会正式从帐号余额扣款，并创建订单。创建好的订单可以在首页看到。 3.3.10 设置个人信息 在首页点击个人信息卡片可以进入个人信息设置页。个人信息可以设置昵称和头像。 3.3.11 钱包操作 在钱包页面可以查看自己的余额。充值需要前往门店，通过付款后管理员增加余额的方式来进行充值。提现操作可以在线上进行，发起提现请求，管理员审核后将钱款打向预留的账户。 3.3.12 地址管理 在个人信息修改页面可以进入地址管理页，可以新增收货地址或删除已经存在的地址。添加好的地址会在创建订单页面显示。 3.3.13 后台登录 进入后台首页会检查登录状态，如果没有登录状态则会跳转到登录页，有登录状态下则会进入系统首页。 3.3.14 后台-订单管理 可以查看全部订单列表，相关管理功能后期拟开发。 3.3.15 后台-物品管理 可以查看全部的物品列表，也可以增加新的物品。新增物品时可以选择新的物品属于哪个门店，并指定物品名称、物品描述、物品价格。可以对物品名称、物品价格、物品描述进行编辑。当然也可以直接删除物品。 3.3.16 后台-商家管理 可以查看全部的商家列表，可以编辑商家名称和商家简介，也可以删除商家。 3.3.17 后台-用户管理 可以以列表的形式查看全部存在的用户，可以编辑用户的昵称。由于没有开发“审核提现申请”的功能，所以在用户管理中增加了可以修改用户余额的功能来满足充值和提现的需求。 3.3.18 注销登录 无论是后台还是APP端，都具有注销登录功能。清除当前用户登录凭证，并退到登录页面。 3.4 用户用例图 图：用户用例图 图：后台管理员用例图 "},"md/4.1.html":{"url":"md/4.1.html","title":"4.1 搭建服务器环境","keywords":"","body":"第4章 开发准备与开发前设计 4.1 搭建服务器环境 4.1.1 使用ssh登录服务器 购买了云主机后会得到一个公网ip，在系统终端下使用如下命令登录服务器。 $ ssh root@47.102.202.86 登录成功后会在终端显示如下提示信息。 $ ssh root@47.102.202.86 root@47.102.202.86's password: Last login: Wed May 22 15:04:07 2019 from 123.185.65.251 Welcome! 这说明当前终端已经是服务器的终端了。接下来我们要安装PHP、MySQL、Apache。 在CentOS系统下，默认的包管理工具是yum，我们本次设计的全部软件包都可以使用yum来下载安装。 4.1.2 安装Apache服务器程序 使用如下命令来安装Apache服务器程序。 $ yum install httpd 安装成功后，控制台会返回如下信息。 $ yum install httpd 已加载插件：fastestmirror Loading mirror speeds from cached hostfile * webtatic: uk.repo.webtatic.com 正在解决依赖关系 --> 正在检查事务 ---> 软件包 httpd.x86_64.0.2.4.6-89.el7.centos 将被 安装 --> 解决依赖关系完成 依赖关系解决 ============================================================================================================================================================= Package 架构 版本 源 大小 ============================================================================================================================================================= 正在安装: httpd x86_64 2.4.6-89.el7.centos updates 2.7 M 事务概要 ============================================================================================================================================================= 安装 1 软件包 总下载量：2.7 M 安装大小：9.4 M Is this ok [y/d/N]: y Downloading packages: httpd-2.4.6-89.el7.centos.x86_64.rpm | 2.7 MB 00:00:00 Running transaction check Running transaction test Transaction test succeeded Running transaction 正在安装 : httpd-2.4.6-89.el7.centos.x86_64 1/1 验证中 : httpd-2.4.6-89.el7.centos.x86_64 1/1 已安装: httpd.x86_64 0:2.4.6-89.el7.centos 完毕！ 安装成功后，使用如下命令启动Apache服务器。 $ service httpd start 控制台返回信息 Redirecting to /bin/systemctl start httpd.service 经过很短的卡顿后，Apache服务器程序启动成功。使用浏览器直接访问服务器的ip地址，可以看到Apache的默认欢迎页。 至此，Apache安装成功。 4.1.3 安装PHP运行环境 使用如下命令来安装php运行环境。 $ yum install php70w php70w是php 7.0软件包的名字，如果yum能找到这个软件包，就会为我们自动安装。如果系统中缺少相关依赖项，yum也会为我们自动找到并且安装。安装过程中会产生如下提示信息，我们可以从中看到一些依赖被自动安装了。 $ yum install php70w 已加载插件：fastestmirror Loading mirror speeds from cached hostfile * webtatic: us-east.repo.webtatic.com 正在解决依赖关系 --> 正在检查事务 ---> 软件包 php70w.x86_64.0.7.0.33-1.w7 将被 安装 --> 正在处理依赖关系 php70w-common(x86-64) = 7.0.33-1.w7，它被软件包 php70w-7.0.33-1.w7.x86_64 需要 --> 正在处理依赖关系 php70w-cli(x86-64) = 7.0.33-1.w7，它被软件包 php70w-7.0.33-1.w7.x86_64 需要 --> 正在处理依赖关系 php70w-cli = 7.0.33-1.w7，它被软件包 php70w-7.0.33-1.w7.x86_64 需要 --> 正在检查事务 ---> 软件包 php70w-cli.x86_64.0.7.0.33-1.w7 将被 安装 ---> 软件包 php70w-common.x86_64.0.7.0.33-1.w7 将被 安装 --> 解决依赖关系完成 依赖关系解决 ============================================================================================================================================================= Package 架构 版本 源 大小 ============================================================================================================================================================= 正在安装: php70w x86_64 7.0.33-1.w7 webtatic 2.8 M 为依赖而安装: php70w-cli x86_64 7.0.33-1.w7 webtatic 2.9 M php70w-common x86_64 7.0.33-1.w7 webtatic 1.2 M 事务概要 ============================================================================================================================================================= 安装 1 软件包 (+2 依赖软件包) 总下载量：6.9 M 安装大小：26 M Is this ok [y/d/N]: y Downloading packages: (1/3): php70w-common-7.0.33-1.w7.x86_64.rpm | 1.2 MB 00:00:03 (2/3): php70w-7.0.33-1.w7.x86_64.rpm | 2.8 MB 00:00:03 (3/3): php70w-cli-7.0.33-1.w7.x86_64.rpm | 2.9 MB 00:02:33 ------------------------------------------------------------------------------------------------------------------------------------------------------------- 总计 46 kB/s | 6.9 MB 00:02:33 Running transaction check Running transaction test Transaction test succeeded Running transaction 正在安装 : php70w-common-7.0.33-1.w7.x86_64 1/3 正在安装 : php70w-cli-7.0.33-1.w7.x86_64 2/3 正在安装 : php70w-7.0.33-1.w7.x86_64 3/3 验证中 : php70w-cli-7.0.33-1.w7.x86_64 1/3 验证中 : php70w-common-7.0.33-1.w7.x86_64 2/3 验证中 : php70w-7.0.33-1.w7.x86_64 3/3 已安装: php70w.x86_64 0:7.0.33-1.w7 作为依赖被安装: php70w-cli.x86_64 0:7.0.33-1.w7 php70w-common.x86_64 0:7.0.33-1.w7 完毕！ 为了测试PHP是否安装成功，我们可以在控制台输入如下命令 $ php -v 来查看PHP的版本号。控制台返回信息是 $ php -v PHP 7.0.33 (cli) (built: Dec 6 2018 22:30:44) ( NTS ) Copyright (c) 1997-2017 The PHP Group Zend Engine v3.0.0, Copyright (c) 1998-2017 Zend Technologies ，说明PHP已经安装成功了。接下来我们前往Apache的网页目录，创建第一个PHP程序，查看一下PHP的信息。 $ cd /var/www/html/ $ vim phpinfo.php 在vim界面下按i进入插入模式，输入如下代码。 按Esc，按:wq保存并退出。在浏览器中访问http://47.102.202.86/phpinfo.php，可以看到PHP输出phpinfo的信息。 至此，php安装成功。 4.1.4 安装MySQL数据库程序 使用如下命令安装MySQL数据库。 $ sudo yum install mysql-server 要安装mysql-server，需要依赖mysql-community-client，在这次安装中会被同时安装。 控制台返回 $ sudo yum install mysql-server 已加载插件：fastestmirror Loading mirror speeds from cached hostfile * webtatic: uk.repo.webtatic.com 正在解决依赖关系 --> 正在检查事务 ---> 软件包 mysql-community-server.x86_64.0.5.7.26-1.el7 将被 安装 --> 正在处理依赖关系 mysql-community-client(x86-64) >= 5.7.9，它被软件包 mysql-community-server-5.7.26-1.el7.x86_64 需要 --> 正在检查事务 ---> 软件包 mysql-community-client.x86_64.0.5.7.26-1.el7 将被 安装 --> 解决依赖关系完成 依赖关系解决 ============================================================================================================================================================= Package 架构 版本 源 大小 ============================================================================================================================================================= 正在安装: mysql-community-server x86_64 5.7.26-1.el7 mysql57-community 166 M 为依赖而安装: mysql-community-client x86_64 5.7.26-1.el7 mysql57-community 24 M 事务概要 ============================================================================================================================================================= 安装 1 软件包 (+1 依赖软件包) 总下载量：190 M 安装大小：853 M Is this ok [y/d/N]: y Downloading packages: (1/2): mysql-community-client-5.7.26-1.el7.x86_64.rpm | 24 MB 00:00:03 (2/2): mysql-community-server-5.7.26-1.el7.x86_64.rpm | 166 MB 00:00:29 ------------------------------------------------------------------------------------------------------------------------------------------------------------- 总计 6.4 MB/s | 190 MB 00:00:29 Running transaction check Running transaction test Transaction test succeeded Running transaction 正在安装 : mysql-community-client-5.7.26-1.el7.x86_64 1/2 正在安装 : mysql-community-server-5.7.26-1.el7.x86_64 2/2 验证中 : mysql-community-server-5.7.26-1.el7.x86_64 1/2 验证中 : mysql-community-client-5.7.26-1.el7.x86_64 2/2 已安装: mysql-community-server.x86_64 0:5.7.26-1.el7 作为依赖被安装: mysql-community-client.x86_64 0:5.7.26-1.el7 完毕！ ，MySQL已经安装成功。接下来要对MySQL进行一定的配置。 刚安装好的MySQL是不允许直接登录的，如果尝试登录，会提示 $ mysql -u root ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (2) 这样的错误信息。查阅了相关资料后，我们得知，第一次登录MySQL需要先配置MySQL跳过鉴权，然后配置好密码再取消跳过鉴权。 先找到MySQL的配置文件，使用vim编辑。 $ vim /etc/my.cnf 在mysqld节点下加入代码 skip-grant-tables 保存并退出，之后重启MySQL $ service mysqld restart Redirecting to /bin/systemctl restart mysqld.service 然后使用命令 $ mysql 就可以直接进入到MySQL命令行下了。 $ mysql Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 2 Server version: 5.7.26 MySQL Community Server (GPL) Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql> 在MySQL命令行下执行如下命令，来修改默认的密码。 mysql> use mysql mysql> update user set authentication_string=password('12312312344456') where user='root'; Query OK, 2 rows affected, 1 warning (0.00 sec) Rows matched: 2 Changed: 2 Warnings: 1 mysql> FLUSH PRIVILEGES; Query OK, 0 rows affected (0.00 sec) mysql> exit Bye 退出MySQL命令行之后，使用vim编辑/etc/my.cnf，在skip-grant-tables左边打一个#号，表示注释。在控制台重启MySQL程序。 service mysqld restart 重启成功后，使用命令连接MySQL数据库。 mysql -u root -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 8 Server version: 5.7.26 MySQL Community Server (GPL) Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql> MySQL数据库在控制台上连接成功。我们尝试一下使用Navicat进行远程连接。 远程连接成功。 至此，我们已经设置好了服务器的基础配置，接下来可以开始准备开发了。 "},"md/4.2.html":{"url":"md/4.2.html","title":"4.2 部署框架代码到服务器","keywords":"","body":"4.2 部署框架代码到服务器 4.2.1 创建github仓库 在部署代码之前，我们首先要确定代码部署方案。在设计阶段，我们决定使用github作为git的中转。在github上建立一个中转的repo，在本地push代码到github，服务器端定时从github上pull代码到本地。 首先我们前往github建立项目。建立项目的时候一定要特别注意的是，要将项目配置为私有。因为本次项目只是用github作为中转，并不想与其他人共享代码。 图：建立一个私有的github repo 建立成功后，我们在本地，使用Github Desktop将代码库clone下来。 将刚创建好的repo clone到本地后，我们编辑根目录的README.md，并使用phpstorm自带的git插件将文件push到github上。 push成功后，打开github网页，刷新页面，可以看到更新结果。 4.2.2 配置服务器git环境 接下来前往服务器，做接下来的事情。由于新安装的服务器没有git功能，所以我们需要先安装git工具。在ssh下连接服务器，执行以下命令来安装git。 $ yum install git 执行成功后，控制台会返回如下的信息。 $ yum install git Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile * webtatic: uk.repo.webtatic.com Resolving Dependencies --> Running transaction check ---> Package git.x86_64 0:1.8.3.1-20.el7 will be installed --> Processing Dependency: perl-Git = 1.8.3.1-20.el7 for package: git-1.8.3.1-20.el7.x86_64 --> Processing Dependency: rsync for package: git-1.8.3.1-20.el7.x86_64 --> Processing Dependency: perl(Term::ReadKey) for package: git-1.8.3.1-20.el7.x86_64 --> Processing Dependency: perl(Git) for package: git-1.8.3.1-20.el7.x86_64 --> Processing Dependency: perl(Error) for package: git-1.8.3.1-20.el7.x86_64 --> Running transaction check ---> Package perl-Error.noarch 1:0.17020-2.el7 will be installed ---> Package perl-Git.noarch 0:1.8.3.1-20.el7 will be installed ---> Package perl-TermReadKey.x86_64 0:2.30-20.el7 will be installed ---> Package rsync.x86_64 0:3.1.2-6.el7_6.1 will be installed --> Finished Dependency Resolution Dependencies Resolved ============================================================================================================================================================================================== Package Arch Version Repository Size ==============================================================================================================================================================================================Installing: git x86_64 1.8.3.1-20.el7 updates 4.4 M Installing for dependencies: perl-Error noarch 1:0.17020-2.el7 base 32 k perl-Git noarch 1.8.3.1-20.el7 updates 55 k perl-TermReadKey x86_64 2.30-20.el7 base 31 k rsync x86_64 3.1.2-6.el7_6.1 updates 404 k Transaction Summary ==============================================================================================================================================================================================Install 1 Package (+4 Dependent packages) Total download size: 4.9 M Installed size: 23 M Is this ok [y/d/N]: y Downloading packages: (1/5): perl-Git-1.8.3.1-20.el7.noarch.rpm | 55 kB 00:00:00 (2/5): perl-TermReadKey-2.30-20.el7.x86_64.rpm | 31 kB 00:00:00 (3/5): perl-Error-0.17020-2.el7.noarch.rpm | 32 kB 00:00:00 (4/5): rsync-3.1.2-6.el7_6.1.x86_64.rpm | 404 kB 00:00:00 (5/5): git-1.8.3.1-20.el7.x86_64.rpm | 4.4 MB 00:00:00 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Total 14 MB/s | 4.9 MB 00:00:00 Running transaction check Running transaction test Transaction test succeeded Running transaction Installing : 1:perl-Error-0.17020-2.el7.noarch 1/5 Installing : rsync-3.1.2-6.el7_6.1.x86_64 2/5 Installing : perl-TermReadKey-2.30-20.el7.x86_64 3/5 Installing : git-1.8.3.1-20.el7.x86_64 4/5 Installing : perl-Git-1.8.3.1-20.el7.noarch 5/5 Verifying : perl-Git-1.8.3.1-20.el7.noarch 1/5 Verifying : 1:perl-Error-0.17020-2.el7.noarch 2/5 Verifying : perl-TermReadKey-2.30-20.el7.x86_64 3/5 Verifying : git-1.8.3.1-20.el7.x86_64 4/5 Verifying : rsync-3.1.2-6.el7_6.1.x86_64 5/5 Installed: git.x86_64 0:1.8.3.1-20.el7 Dependency Installed: perl-Error.noarch 1:0.17020-2.el7 perl-Git.noarch 0:1.8.3.1-20.el7 perl-TermReadKey.x86_64 0:2.30-20.el7 rsync.x86_64 0:3.1.2-6.el7_6.1 Complete! 在服务器上安装git成功后，我们手动将刚创建好的repo clone下来。 $ git clone https://github.com/xtzero/finalDesign1.git 4.2.3 使用shell脚本让服务器的代码可以自动更新 clone成功后，在服务器上我们编辑这样两个shell脚本。 for.sh #!/bin/bash for((i=0;i==0;i=i+0)) do sleep 5s ~/git.sh; done git.sh #!/bin/bash cd /var/www/html/xtBlog/ && git pull 第一个脚本是每隔5秒就调用第二个脚本，第二个脚本的作用是从github上拉取最新的代码。 然后我们在控制台上执行这样一个命令 nohup ./for.sh & 这样服务器就会每5秒从github上pull一次最新的代码。在后面的开发中，我们只需要在本地将代码push到github上，稍等5秒就可以刷新页面看到最新的运行结果了。 4.2.4 将框架代码部署到服务器 我们将准备好的初始代码复制到github项目文件夹下，使用phpstorm自带的git功能将文件push到服务器上。 上传成功后，前往服务器的git目录下，可以看到文件已经存在于服务器目录下了。 至此，我们已经将初始代码全部部署到服务器上。下一步的工作就是为服务器绑定域名，然后开始功能上的开发。 "},"md/4.3.html":{"url":"md/4.3.html","title":"4.3 设置域名解析","keywords":"","body":"4.3 设置域名解析 域名和ip地址一样，是一个独立的标识。由于ip地址不利于记忆，又有商标等相关需求。于是便有了域名的设定。域名可以作为一个独一无二的标题出现在用户面前，或为新奇，或为品牌标识。随着互联网的发展，域名竞争也日渐激烈。一个好的域名甚至可以卖上很大一笔好价钱。 域名解析的配置相对简单，我们只需要前往域名商处注册一个心仪的域名，将A解析指向服务器的ip地址，过十分钟左右访问域名就可以看到效果了。 "},"md/5.html":{"url":"md/5.html","title":"第5章 数据库设计","keywords":"","body":"第5章 数据库设计 5.1 概念结构设计 在本节我们使用E-R 图来进行数据库的初步设计。E-R 图只表示实体-属性之间的关系，和实体间的联系，无关于DBMS。依照E-R 图可以在任意DBMS 下建立表结构。 图：系统E-R图 5.2 逻辑结构设计 在本节，我们要将E-R 图中表示的实体-关系之间的联系转换为关系模式，并在关系模式下确定主键和外键的关系。 在E-R 图中的用户部分，涉及了用户的基本属性。用于与订单产生联系，订单与商品产生联系。四个实体之间是一条线的关系。 整个数据库的逻辑结构如下。 用户（用户id，昵称，头像，密码，余额） 主键：用户id 订单（订单id，创建人id，订单地址，收货人，订单现价，订单原价） 主键：订单id；外键：创建人id 店铺（店铺id，店铺名字，店铺简介） 主键：店铺id 商品（商品id，店铺id，商品名字，商品价格，订单） 主键：商品id；外键：店铺id 商品-订单（商品订单id，商品id，订单id） 主键：商品订单id；外键：商品id，订单id 上述逻辑关系可以用下图来表示。 5.3 数据库的物理实现 在数据库的物理实现上，我们将从 DBMS的选择开始，直到每一个数据表都建成。根据前两节的概念及逻辑结构设计，已经得到了数库无关于DBMS的设计方案，在这一节我们将前文所述落实到际的DBMS上，进行更详细的设计。 在 DBMS上，我们选择 MySQL，配合 原生的PHP MySQL 扩展可以发挥其最大的优势。 创建数据表 user，用于存储户信息。其中 id 是主键，为用户表的索引行。 同时也是唯一字段，为查询提供索引。 执行如下语句来创建user表。 CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `usr` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL, `pwd` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL, `valid` int(1) DEFAULT '1', `create_at` datetime DEFAULT NULL, `update_at` datetime DEFAULT NULL, `nickname` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL, `icon` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL, `type` varchar(10) COLLATE utf8_unicode_ci DEFAULT '1', `restMoney` float(10,2) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci; 创建数据表token，用于存储用户的登录凭证。其中id是主键，userid是外键，为user表中的id。执行下面的语句来创建token表。 CREATE TABLE `token` ( `id` int(11) NOT NULL AUTO_INCREMENT, `token` varchar(255) COLLATE utf8_unicode_ci NOT NULL, `userid` int(11) NOT NULL, `die_at` datetime DEFAULT NULL, `create_at` datetime DEFAULT NULL, `valid` int(1) DEFAULT '1', PRIMARY KEY (`id`,`token`,`userid`) ) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci; 创建user_addr表，用于存放用户的地址信息。其中id是主键，userid是外键。 CREATE TABLE `user_addr` ( `id` int(11) NOT NULL AUTO_INCREMENT, `userid` int(11) NOT NULL, `addr` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL, `name` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL, `phone` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL, `valid` int(1) DEFAULT '1', `create_at` datetime DEFAULT NULL, PRIMARY KEY (`id`,`userid`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci; 创建shop表，用于存放店铺的相关信息。其中id是主键。 CREATE TABLE `shop` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL, `create_at` datetime DEFAULT NULL, `valid` int(1) DEFAULT '1', `notice` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci; 创建goods表，用于存放商品信息。其中id是主键。 CREATE TABLE `goods` ( `id` int(11) NOT NULL AUTO_INCREMENT, `shopId` int(11) DEFAULT NULL, `name` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL, `describe` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL, `create_at` datetime DEFAULT NULL, `price` decimal(10,2) DEFAULT NULL, `image` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL, `valid` int(1) DEFAULT '1', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci; 创建order表，用于存放订单信息。其中id是主键，userid是外键。 CREATE TABLE `order` ( `id` varchar(32) COLLATE utf8_unicode_ci NOT NULL, `userid` int(11) NOT NULL, `create_at` datetime DEFAULT NULL, `ori_price` decimal(10,2) DEFAULT NULL, `price` decimal(10,2) DEFAULT NULL, `name` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL, `phone` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL, `addr` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL, `valid` int(1) DEFAULT '1', `status` int(1) DEFAULT '1', PRIMARY KEY (`id`,`userid`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci; 创建order_goods表，用于存放订单-商品信息。其中id是主键，orderId、goodId是外键，分别是订单id和商品id。 CREATE TABLE `order_goods` ( `id` int(11) NOT NULL AUTO_INCREMENT, `orderId` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL, `goodId` int(11) DEFAULT NULL, `create_at` datetime DEFAULT NULL, `ori_price` decimal(10,2) DEFAULT NULL, `price` decimal(10,2) DEFAULT NULL, `valid` int(1) DEFAULT '1', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci; 创建goods_price_control表，用于额外控制商品价格。这个机制的具体设计思路会在后边详细描述。表中id是主键，goodId是外键。 CREATE TABLE `good_price_control` ( `id` int(11) NOT NULL AUTO_INCREMENT, `goodId` int(11) NOT NULL, `begin_at` datetime DEFAULT NULL, `end_at` datetime DEFAULT NULL, `valid` int(1) DEFAULT '1', `price` decimal(10,2) DEFAULT NULL, `type` int(1) DEFAULT '1', `incOrDec` int(1) DEFAULT NULL, PRIMARY KEY (`id`,`goodId`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci; 创建money_log表，用于存放用于余额变动的记录。其中id是主键，userid是外键。 CREATE TABLE `money_log` ( `id` int(11) NOT NULL AUTO_INCREMENT, `userid` int(11) NOT NULL, `money` float(10,2) DEFAULT NULL, `afterChange` float(10,2) DEFAULT NULL, `create_at` datetime DEFAULT NULL, `reason` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL, `valid` int(1) DEFAULT '1', PRIMARY KEY (`id`,`userid`) ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci; "},"md/6.html":{"url":"md/6.html","title":"第6章 编码开发","keywords":"","body":"第六章 编码开发 在这一章，我们会按照项目实施的时间顺序，对整个系统进行分模块的描述。对每一个模块，都会描述其设计思想以及具体的实现方案。 6.1 后端架构设计 后端在架构上借鉴了传统MVC的思想，开发了一个简单且轻巧的php框架。框架使用多个入口，即每个文件都是一个单独的控制器。每个控制器通过参数来控制去实现哪个方法，使用这种方式实现了传统意义上的路由。 6.1.1 框架结构 框架的基本结构是 ./ ./lib //库目录 ./lib/common.php //公共函数库 ./lib/db.php //数据库类 ./lib/dbUtil.php //数据库逻辑层 ./lib/entry.php //控制器唯一入口 ./oneController.php //一个对外的控制器 6.1.2 程序入口 每个控制器都要继承entry.php中的entry类，entry类提供了一系列的控制器方法，可以方便开发。 在entry.php中，对程序入口的定义可以体现在 可以看到，entry.php引入了函数库文件、数据库类库、数据库逻辑层。可能这样讲还不太容易理解，我们接下来看一个实际的控制器。 param('method'); if(in_array($this->method,[ 'listShop', 'addShop', 'delShop', 'getShopInfo', 'editShopInfo' ])){ $this->{$this->method}(); }else{ error('error method：'.$this->method); } } //more func here... } runApp(); 再配合一个实际在用的接口来看： http://xtzero.me/dressupAsMeituan/api/shop.php?method=listShop 在访问接口的时候，实际上是访问了具体的某一个控制器文件。控制器引入了入口控制器entry，入口控制器引入了其他需要用的类库。最后最外层的控制器使用runApp来开启整个程序。对runApp函数的定义是 /** * 实例化类，运行程序 */ function runApp(){ $a = strrpos($_SERVER['PHP_SELF'],'/')+1; $b = strrpos($_SERVER['PHP_SELF'],'.')+1; $className = substr($_SERVER['PHP_SELF'],$a,$b-$a-1); try{ $c = new $className; $c->run(); }catch(Exception $e){ displayException($e); } } runApp会根据当前域名去获取对应的类，直接去执行该类下的run方法。这样，一个接口就启动了。 6.1.3 数据库类 在数据库类的设计上，采用了著名的单例模式。所谓单例模式，即一个类只能被实例化一次，再实例化的时候就会返回之前已经存在的实例。这种设计需要重载构造函数，将构造函数设为私有，这样就不能通过new来实例化新的对象。并且要为使用这个类的开发者留另一个入口，在即将创建新的对象的时候将动作拦截下来，并返回之前创建好的对象。 一个单例模式的实例如下 class single{ private static $obj = null; private function __construct(){ } public static function init(){ if(self::$obj === null){ self::$obj = new self(); } return self::$obj; } } 基于这个设计思想，我们使用如下的代码来定义数据库类。 db_host = (strpos($_SERVER['HTTP_HOST'],'localhost') !== false)? 'ip:3306' : 'localhost'; $db = mysqli_connect($this->db_host,$this->db_usr,$this->db_pwd); if($db){ mysqli_select_db($db,'dbName'); mysqli_query($db,'set names \\'utf8\\''); $this->db = $db; return $this; }else{ error('数据库链接失败：'.mysqli_error($db)); } } public static function init(){ if(self::$obj === null){ self::$obj = new self(); } return self::$obj; } } function __destruct(){ if($this->db){ mysqli_close($this->db); } } 除了使用单例模式的设计之外，数据库类还提供了简单的数据库方法。query方法负责执行sql语句，并根据传入的第二个参数来决定是否要将sql执行结果变为php可读的数据。对query方法的定义是 public function query($sql,$dbResultToArray = false){ if($this->db){ $res = mysqli_query($this->db,$sql); if($dbResultToArray){ if($res){ $res = fetchDbResult($res); }else{ $res = []; } } return $res; }else{ error('db instance not found!'); die(); } } 需要和query配合使用的是fetchDbResult，对这个方法的定义是 function fetchDbResult($dbResult){ $data = []; while($row = mysqli_fetch_assoc($dbResult)){ $data[] = $row; } return $data; } 使用error方法来获取sql执行的错误信息。 public function error(){ if($this->db){ $res = mysqli_error($this->db); return $res; }else{ error('db instance not found!'); die(); } } 对数据库类，还需要解释的是： 这里的数据库指的是后端程序与数据库之间的层，相当于传统MVC结构中的Model层。 数据库类写在/lib/db.php中，写在db类中。 db类使用单例模式，不提供具体的数据库操作，只负责数据库的连接与SQL的执行。 db::init()方法负责初始化数据库与找到当前数据库链接，返回当前数据库链接对象。 db->query()方法负责执行SQL语句，返回mysqli_query的原始返回值。如果当前SQL语句是查询语句，可以向query()函数的第二个参数传入true，来使query()方法返回mysqli_fetch_array的返回结果。 下面是使用db类执行一个单条SQL语句的例子。 $res = db::init() -> query(\"INSERT INTO user(usr,pwd,valid,create_at,update_at) VALUES('{$usr}','{$pwd}',1,'{$today}','{$today}');\"); 上面的代码会直接返回INSERT语句执行的结果。 而下面的代码会返回SELECT语句经过处理后的数组。 $today = date('Y-m-d H:i:s',time()); $fields = 'user.id as userid,user.usr,user.nickname,user.icon'; $res = db::init() -> query(\"SELECT {$fields} FROM token LEFT JOIN user ON token.userid=user.id WHERE token.token='{$token}' AND token.die_at>'{$today}' AND user.valid=1;\",true); 6.1.4 参数验证方法 继承entry类之后可以在控制器中使用的方法。支持必要/非必要、get/post四种任意组合情况的参数验证。 函数原型是 int param($paramStr,$method) 参数列表是 参数名 类型 解释 可能值 举例 $paramStr String 参加验证的表达式 Any String 'username' $method String 接收参数的方式 'g'或'p' 'g' 返回值/运行结果 缺少参数的时候会报错（在entry.php中定义）。 运行成功时返回验证成功的参数数量。 假如前端访问的接口是 ?method=egFunc&param1=value1 使用控制器继承了entry类，在方法头部使用 $this->param('method,param1'); 来接受参数，这时可以在程序中这样子取到这两个值： $this->method // == 'egFunc' $this->param1 // == 'value1' 支持的参数验证表达式 参数之间使用英文逗号,连接。 直接写参数名称为必要的参数验证，如果前端没有传来这个参数，则会中断程序运行并报错。 参数名称左边加星号*为不必要的参数验证，即使前端没有传这个参数，程序也会继续执行。这时该参数的值以默认值处理为准。如果前端提供了这个参数值，那么默认值处理不生效。 默认值处理，即在不必要的参数验证的参数名后边接=参数默认值。例如*param2=abc，这时如果访问的url中不包含param2，直接取param2 的时候则会取到abc。 无论是必要的还是非必要的参数验证，都可以使用param1>>int的形式来进行参数类型转换。>>号后边支持的关键字有int、string、float、array。 下面是验证参数表达式的几种例子。 par1 会获取前端传来的par1参数，如果前端没有提供，则程序终止并报错。 *par1 会获取前端传来的par1参数。即使前端没有提供也不会终止程序，但是由于没有默认值，如果前端没有提供这个参数值，则这个参数没有值。 *par1=123 会获取前端传来的par1参数。即使前端没有提供也不会终止程序。由于提供了默认值，当前端没有提供参数值的时候，以默认值为准；如果前端提供了参数值，则该参数为前端提供的值。 par1>>int 接收前端传来的par1参数，并转换为int类型。 6.1.5 模型 Model 这里的模型指的是具体的某些数据库操作的集合，相当于一些框架的DAO层。 所有的模型操作都定义在/lib/dbUtil.php中，使用不同的类名来进行分类。也就是说，这个dbUtil.php文件中会包含若干个类。 由于模型只包含独立的数据库操作，不涉及继承关系。模型中的方法全部使用静态方法。这样设计之下，在控制器中只需要使用Classname::funcName()的方式直接调用即可。 下面是一个模型的举例 /** * 账号相关model */ class accountModel{ /** * 检查用户是否存在 */ public static function ifUserExist($usr){ $res = db::init() -> query(\"SELECT * FROM user WHERE usr='{$usr}' AND valid=1\",true); if($res){ return true; }else{ return false; } } /** * 检查用户密码 */ public static function usrConfirm($usr,$pwd,$returnUserInfo = false){ $pwd = md5(md5($pwd)); $res = db::init() -> query(\"SELECT * FROM user WHERE usr='{$usr}' AND pwd='{$pwd}' AND valid=1;\",true); if($res){ if($returnUserInfo){ return $res[0]; }else{ return true; } }else{ return false; } } } 在控制器中这样调用上面定义的模型方法。 accountModel::usrConfirm($this->usr,$this->pwd); 6.1.6 函数库 函数库写在/lib/common.php文件中。 函数库在/lib/entry.php中被引入，所以函数库中的所有函数可以在程序的任何位置被使用。通常在这里写入一些作为工具使用的函数。 下面是一些框架自带且必要的函数。 crossDomain 允许跨域请求。 ajax 向前端返回数据包。可以根据需要来改变数组结构。 error 终止程序，显示异常信息。 6.1.7 登录与权限验证机制 系统使用token机制来保存登录状态。 用户执行了登录接口后，会将登录凭证保存在token表中。在每个控制器中，如果需要检查登录状态，在继承了entry类之后，就可以使用 $this->checkToken(); 方法来检查接口是否包含了登录信息。如果没有token参数，接口会返回缺少token参数。如果token验证成功，可以使用 $this->__userinfo; 来获取token对应的用户信息。checkToken方法的定义是 /** * 检查token方法 */ public function checkToken(){ $this->param('token'); $userinfo = tokenModel::getTokenInfo($this->token); if($userinfo){ $this->__userinfo = $userinfo; }else{ ajax(100001,'登录态已过期，请重新登录。'); } } 这个方法会先检查token参数，随后使用tokenModel去获取用户信息，然后存入$this->__userinfo中，让用户信息可以全局使用。 如果需要检查用户权限，同样地，在继承了entry之后，可以使用 $this->checkUserType(); 来检查用户权限是否满足要求。在本系统中，由于对角色权限的要求不是很高，所以没有设计为最常见的“角色-权限”模式，而是在user表中添加了一个type字段，使用checkUserType检查用户是否符合要求。checkUserType方法的定义是 /** * 检查用户类型方法 */ public function checkUserType($needType){ if($this->__userinfo){ if(is_array($needType)){ if(!in_array($this->__userinfo['type'],$needType)){ ajax(100002,'用户类型不符合要求'); } }else{ if($this->__userinfo['type'] != $needType){ ajax(100003,'用户类型不符合要求'); } } }else{ error('checkUserType之前请先checkToken!'); } } 需要特别注意的是，checkUserType要在checkToken之后使用。 "},"md/6.2.html":{"url":"md/6.2.html","title":"6.2 后端接口开发","keywords":"","body":"6.2 后端接口开发 本节将会从后端的角度出发，完整描述每一个接口的实现过程。 对于接口的实现，在公共函数库lib/common.php中还有这样一个函数，专门负责向前端返回数据包。 function ajax($code,$msg,$data = []){ echo json_encode([ 'code' => $code, 'msg' => $msg, 'data' => $data ]); die(); } 在每个接口的实现中，都会出现这个函数，作为程序的出口，向前端返回json格式的数据。 6.2.1 登录 登录接口接收前端传入的用户名和密码，将密码加密后与数据库中已存在的密码比对。如果正确，生成登录凭证token，返回给前端。 控制器实现 private function login(){ $this->param('usr,pwd'); if(accountModel::ifUserExist($this->usr)){ if($userinfo = accountModel::usrConfirm($this->usr,$this->pwd,true)){ $today = date('Y-m-d H:i:s',time()); $token = md5($this->usr.'|'.$today); $res = tokenModel::saveToken($token,$userinfo['id']); if($res){ $userinfo = tokenModel::getTokenInfo($token); if($userinfo){ $userinfo['token'] = $token; ajax(0,'成功',$userinfo); }else{ ajax(-1,'插入数据时出现错误，请稍后重试',['ret' => -1]); } }else{ ajax(-1,'插入数据时出现错误，请稍后重试',['ret' => -2]); } }else{ ajax(2,'用户名或密码不正确'); } }else{ ajax(1,'用户不存在'); } } 模型实现 public static function ifUserExist($usr){ $res = db::init() -> query(\"SELECT * FROM user WHERE usr='{$usr}' AND valid=1\",true); if($res){ return true; }else{ return false; } } public static function usrConfirm($usr,$pwd,$returnUserInfo = false){ $pwd = md5(md5($pwd)); $res = db::init() -> query(\"SELECT * FROM user WHERE usr='{$usr}' AND pwd='{$pwd}' AND valid=1;\",true); if($res){ if($returnUserInfo){ return $res[0]; }else{ return true; } }else{ return false; } } public static function saveToken($token,$userid){ $today = date('Y-m-d H:i:s',time()); $sevenDaysAfter = date('Y-m-d H:i:s',time() + 604800); $res = db::init() -> query(\"INSERT INTO token(userid,token,create_at,die_at) VALUES({$userid},'{$token}','{$today}','{$sevenDaysAfter}');\"); if($res){ return true; }else{ return false; } } public static function getTokenInfo($token){ $today = date('Y-m-d H:i:s',time()); $fields = 'user.id as userid,user.usr,user.nickname,user.icon,user.type'; $res = db::init() -> query(\"SELECT {$fields} FROM token LEFT JOIN user ON token.userid=user.id WHERE token.token='{$token}' AND token.die_at>'{$today}' AND user.valid=1;\",true); if($res){ return $res[0]; }else{ return false; } } 6.2.2 店铺-列表 店铺列表接口接收page参数，用于分页显示店铺信息。如果page=ALL，则接收全部店铺信息。 控制器实现 private function listShop(){ $this -> param('*page=ALL'); $res = shopModel::listShop($this->page,10); ajax(0,'成功',$res); } 模型实现 public static function listShop($page = 1,$pageLimit = 10){ $fields = 'id,name,notice,create_at'; if($page == \"ALL\"){ $sql = \"SELECT {$fields} FROM shop WHERE valid=1;\"; }else{ $beginIndex = ($page - 1) * $pageLimit; $sql = \"SELECT {$fields} FROM shop WHERE valid=1 LIMIT {$beginIndex},{$pageLimit};\"; } $res = db::init() -> query($sql,true); return $res; } 6.2.3 店铺 - 查看店铺详情与物品列表 店铺详情与物品列表是两个接口，但是在同一个页面被同时调用。店铺详情接口接收一个店铺id，店铺id来自上一个接口，在店铺列表中获取。物品列表同样接收一个店铺id，同时接收page参数，用于分页。 控制器实现 private function getShopInfo(){ $this->param('shopId'); $res = shopModel::getShopInfo($this->shopId); if($res){ ajax(0,'成功',$res); }else{ ajax(1,'没有获取到这个店铺'); } } private function listGoods(){ $this -> param('shopId,*page=1'); $res = goodsModel::listGoods($this->shopId,$this->page,10); ajax(0,'成功',$res); } 模型实现 public static function getShopInfo($shopId){ $sql = \"SELECT * FROM shop WHERE id={$shopId} AND valid=1;\"; $res = db::init() -> query($sql,true); if($res){ return $res[0]; }else{ return false; } } public static function listGoods($shopId = FALSE,$page = 1,$pageLimit = 1000000){ $beginIndex = ($page - 1) * $pageLimit; //要取到所有的商品 if ($shopId) { $sql = \"SELECT * FROM goods WHERE shopId={$shopId} AND valid=1 LIMIT {$beginIndex},{$pageLimit}\"; } else { $sql = \"SELECT * FROM goods WHERE valid=1 LIMIT {$beginIndex},{$pageLimit}\"; } $goodsArr = db::init() -> query($sql,true); if($goodsArr){ //所有商品id的字符串 $goodIdsStr = implode(',',array_keys(keyToIndex($goodsArr,'id'))); $goodsArr = self::calcPrice($goodsArr); } $shopsSql = \"SELECT * FROM shop WHERE id IN ({$goodIdsStr});\"; $shops = db::init() -> query($shopsSql, true); if ($shops) { $shops = keyToIndex($shops, 'id'); foreach ($goodsArr as $k => $v) { $goodsArr[$k]['shopname'] = $shops[$v['shopId']]['name']; } } return $goodsArr; } 6.2.4 订单 - 创建订单 创建订单接收物品列表、收货人、收货人手机号、收货地址。会在模型中判断每个商品是否存在，计算价格后将订单信息保存。 控制器实现 public function createOrder() { $this->param('goodsList,name,*phone,*addr=eat_in_shop'); $this->checkToken(); if ($this->addr != 'eat_in_shop' && !$this->phone) { ajax(-2, '请填写联系方式'); } $res = orderModel::createOrder($this->goodsList, $this->__userinfo['userid'], $this->name, $this->phone, $this->addr); switch ($res) { case -1: ajax(-1, '创建订单时出现错误，请稍后重试'); break; case 1: ajax(1, '订单中有已下架商品，请重新添加'); break; case 2: ajax(2, '余额不足，请联系店家充值'); break; default: ajax(0, '创建订单成功', [ 'orderId' => $res ]); } } 模型实现 public static function createOrder($goodIds,$userid,$name,$phone,$addr){ $orderId = appendOrderId(); $goodsArr = db::init() -> query(\"SELECT * FROM goods WHERE id IN ({$goodIds}) AND valid=1;\",true); $goodsIdsValidIs1 = implode(',',array_keys(keyToIndex($goodsArr,'id'))); if(strlen($goodIds) == strlen($goodsIdsValidIs1)){ //计算好的商品列表 $goodsArr_ = goodsModel::calcPrice($goodsArr); //计算原价和订单价 $oriPrice = 0; $price = 0; foreach($goodsArr_ as $k => $v){ $oriPrice += $v['price']; if($v['newPrice']){ $price += $v['newPrice']; }else{ $price += $v['price']; } } if(moneyModel::disMoney($userid,$price,$reason = 'system dis') === 0){ //保存订单信息 $saveOrderSql = \"INSERT INTO `order`(id,userid,create_at,ori_price,price,name,phone,addr) VALUES('{$orderId}',{$userid},now(),{$oriPrice},{$price},'{$name}','{$phone}','{$addr}');\"; $saveOrder = db::init() -> query($saveOrderSql); //保存订单物品信息 $saveOrderGoodsSql = \"INSERT INTO `order_goods`(orderId,goodId,create_at,ori_price,price) VALUES\"; $saveOrderGoodsSqlTailArr = []; foreach($goodsArr_ as $k => $v){ if($v['newPrice']){ $price = $v['newPrice']; }else{ $price = $v['price']; } $oriPrice = $v['price']; array_push($saveOrderGoodsSqlTailArr,\"('{$orderId}',{$v['id']},now(),{$oriPrice},{$price})\"); } $saveOrderGoodsSql .= implode(',',$saveOrderGoodsSqlTailArr); $saveOrderGoods = db::init() -> query($saveOrderGoodsSql); if($saveOrder && $saveOrderGoods){ return $orderId; }else{ return -1; } }else{ //余额不足 return 2; } }else{ //有商品已下架 return 1; } } 6.2.5 订单 - 查看订单列表 订单列表要求登录状态，根据当前的登录用户，获取订单列表。 控制器实现 public function listMyOrder() { $this->checkToken(); $res = orderModel::listOrder($this->__userinfo['userid']); if ($res) { ajax(0, '成功', $res); } else { ajax(1, '没有任何数据'); } } 模型实现 public static function listOrder($userid = false){ if ($userid) { $sql = \"SELECT * FROM `order` WHERE userid={$userid} AND valid=1\"; } else { $sql = \"SELECT * FROM `order` WHERE valid=1\"; } $res = db::init()->query($sql,true); if($res){ foreach($res as $k => $v){ $orderId = $v['id']; $goodSql = \"SELECT * FROM order_goods og LEFT JOIN goods AS g ON og.goodId=g.id WHERE og.orderId='{$orderId}';\"; $goods = db::init() -> query($goodSql,true); $res[$k]['goods'] = $goods; } return $res; }else{ return false; } } 6.2.5 用户 - 查看基本信息 查看基本信息接口要求有登录状态，接口会根据当前登录的用户去获取该用户的基本信息。 控制器实现 private function getUserInfo(){ $this->param('*field=all'); $this->checkToken(); $res = userModel::getUserInfo($this->__userinfo['userid'],$this->field); if($res){ ajax(0,'成功',$res); }else{ ajax(1,'没有查询到结果',$this->__userinfo); } } 模型实现 public static function getUserInfo($userid,$field = '*'){ if($field == 'all'){ $field = 'id,usr,nickname,icon,restMoney'; } $sql = \"SELECT {$field} FROM user WHERE id={$userid} AND valid=1;\"; $res = db::init() -> query($sql,true); if($res){ return $res[0]; }else{ return false; } } 6.2.6 用户 - 修改用户信息 修改用户信息接口需要接受字段名和新的字段值。并且要在接口接受参数后进行限制，不允许修改一些高危的字段值。 控制器实现 private function setUserInfo(){ $this->checkToken(); $this->param('key,value,*userid'); if(in_array($this->key,[ 'nickname', 'icon', 'restMoney' ])){ if (!$userid) { $this->userid = $this->__userinfo['userid']; } $res = userModel::setUserInfo($this->userid,$this->key,$this->value); if($res){ ajax(0,'成功'); }else{ ajax(-1,'修改失败，请稍后重试'); } }else{ ajax(1,'不支持修改的项目'); } } 模型实现 public static function setUserInfo($userid,$key,$value){ $sql = \"UPDATE user SET {$key}='{$value}' WHERE id={$userid} AND valid=1;\"; $res = db::init() -> query($sql); return $res; } 6.2.7 用户 - 查看全部收货地址 会根据当前登录的用户来获取所有该用户创建的收货地址。 控制器实现 private function listUserAddr(){ $this->checkToken(); $res = userModel::getUserAddr($this->__userinfo['userid']); if($res){ ajax(0,'成功',$res); }else{ ajax(-1,'获取地址列表失败，请稍后重试'); } } 模型实现 public static function getUserAddr($userid){ $sql = \"SELECT * FROM user_addr WHERE userid={$userid} AND valid=1;\"; $res = db::init() -> query($sql,true); if($res){ return $res; }else{ return false; } } 6.2.8 用户 - 管理收货地址 对收货地址的管理，包含添加和删除。添加收货地址时，需要提供收货人、收货地址、联系人手机号三个参数。在查看收货地址时会得到当前地址的id，删除收货地址时传入这个id就可以完成删除。 控制器实现 private function addUserAddr(){ $this->checkToken(); $this->param('addr,name,phone'); $res = userModel::addUserAddr($this->__userinfo['userid'],$this->addr,$this->name,$this->phone); if($res){ ajax(0,'成功'); }else{ ajax(-1,'添加地址失败，请稍后重试'); } } private function deleteUserAddr(){ $this->checkToken(); $this->param('addrId'); $res = userModel::deleteUserAddr($this->__userinfo['userid'],$this->addrId); switch($res){ case 0: ajax(0,'成功');break; case 1: ajax(1,'该地址不存在');break; case -1: ajax(-1,'删除地址失败，请稍后重试');break; } } 模型实现 public static function addUserAddr($userid,$addr,$name,$phone){ $sql = \"INSERT INTO user_addr(userid,addr,name,phone,valid,create_at) VALUES({$userid},'{$addr}','{$name}','{$phone}',1,now());\"; $res = db::init() -> query($sql); return $res; } public static function deleteUserAddr($userid,$addrId){ $ifBelongSql = \"SELECT id FROM user_addr WHERE id={$addrId} AND userid={$userid} AND valid=1;\"; $ifBelong = db::init() -> query($ifBelongSql,true); if($ifBelong){ $sql = \"UPDATE user_addr SET valid=0 WHERE id={$addrId} AND valid=1\"; $res = db::init() -> query($sql); return (bool)$res?0:-1; }else{ //这个地址不属于这个用户，或者是不存在 return 1; } } 6.2.9 后台 - 创建店铺 后台接口需要检查登录态，并根据登录态判断用户类型。当用户符合要求的类型时，才能进行接下来的逻辑。创建店铺需要提供店铺名字，并且可选择地提供店铺的描述。 控制器实现 private function addShop(){ $this->param('name,*notice'); $this->checkToken(); $this->checkUserType('admin'); $res = shopModel::addShop($this->name,$this->notice); if($res){ ajax(0,'成功'); }else{ ajax(-1,'添加商品失败，请稍后重试'); } } 模型实现 public static function addShop($name,$notice = ''){ $sql = \"INSERT INTO shop(name,notice,create_at,valid) VALUES('{$name}','{$notice}',now(),1);\"; $res = db::init() -> query($sql); return (bool)$res; } 6.2.10 后台 - 修改店铺信息 检查用户类型后，需要提供想要修改的字段名，和新的值。控制器会对字段值进行判断，只允许修改指定的几个字段。 控制器实现 private function editShopInfo(){ $this->checkToken(); $this->param('shopId,key,value'); if (!in_array($this->key, ['name','descr','notice'])) { ajax(1,'不允许修改这个字段'); } else { $res = shopModel::editShopInfo($this->shopId, $this->key, $this->value); if ($res) { ajax(0,'成功'); } else { ajax(-1, '修改店铺信息时出现错误，请稍后重试'); } } } 模型实现 public static function editShopInfo($shopId,$key,$value){ $sql = \"UPDATE shop SET {$key}='{$value}' WHERE id={$shopId};\"; $res = db::init() -> query($sql); return $res; } 6.2.11 后台 - 添加物品 添加商品需要在验证用户状态后提供店铺id、物品名字、价格。并且有可选参数，物品描述、物品图片。 控制器实现 private function addGoods(){ $this->param('shopId,name,*describe,price,*image'); $this->checkToken(); $this->checkUserType('admin'); $res = goodsModel::addGoods($this->name,$this->price,$this->image,$this->shopId,$this->describe); if($res){ ajax(0,'成功'); }else{ ajax(-1,'添加商品失败，请稍后重试'); } } 模型实现 public static function addGoods($name,$price,$image = '',$shopId,$describe = ''){ $today = date('Y-m-d H:i:s',time()); $sql = \"INSERT INTO goods(shopId,`name`,create_at,price,image,valid,`describe`) VALUES({$shopId},'{$name}','{$today}',{$price},'{$image}',1,'{$describe}');\"; $res = db::init() -> query($sql); return (bool)$res; } 6.2.12 后台 - 删除物品 删除物品接口需要提供物品id，删除时只是修改了valid字段，让列出物品的时候不会显示出来。 控制器实现 private function deleteGoods(){ $this->param('goodId'); $this->checkToken(); $this->checkUserType('admin'); $res = goodsModel::deleteGoods($this->goodId); if($res){ ajax(0,'成功'); }else{ ajax(-1,'失败'); } } 模型实现 public static function deleteGoods($goodsId){ $sql = \"UPDATE goods SET valid=0 WHERE id={$goodsId};\"; $res = db::init() -> query($sql); return $res; } 6.2.13 后台 - 查看订单列表 后台查看订单列表不会根据当前登录态来筛选订单，而是会获取全部的订单列表。 控制器实现 public function orderList() { $this->checkToken(); $res = orderModel::listOrder(); if ($res) { ajax(0, '成功', $res); } else { ajax(1, '没有任何数据'); } } 这个接口与用户的订单列表共用同一个模型，传入的参数不同，实现的结果不一样。 6.2.14 后台 - 查看所有用户列表 这个接口会获取全部的用户列表。当然获取之前要检查当前登录态是否为管理员。 控制器实现 public function listAllUser(){ $this->checkToken(); $this->checkUserType('admin'); $res = userModel::listAllUser(); if($res){ ajax(0,'成功',$res); }else{ ajax(-1,'没有任何数据'); } } 模型实现 public static function listAllUser(){ $sql = \"SELECT * FROM user\"; $res = db::init() -> query($sql,true); return $res; } 6.2.15 后台 - 修改用户信息 修改用户信息接口和用户修改自己信息的接口共用同一个控制器，如果当前登录状态是管理员，则可以修改任何人的用户信息，并且对管理员开放修改restMoney字段的权限，即可以修改用户的余额。 "},"md/6.3.html":{"url":"md/6.3.html","title":"6.3 app端前端页面与逻辑","keywords":"","body":"6.3 app端前端页面与逻辑 本节将会从各个细节描述app端的实现方式。每个页面分为设计部分与逻辑部分。 6.3.1 登录与登录凭证保存 由于web app使用html5+的环境，故可以使用plus.storage相关的底层接口来操作本地存储。登录凭证通过登录接口获取，获取到的登录凭证就存放在本地存储plus.storage中。在登录页面我们可以看到这样的逻辑： //more code... if(res.code == 0){ for(var i in res.data){ plus.storage.setItem(i,res.data[i]); } //more code... 这样，登录接口所返回的个人信息数据就全部存储到了本地存储localStorage中了。当需要使用的时候，可以使用 var token = plus.storage.getItem('token'); 来获取。 6.3.2 标题和导航 在设计App的结构时，最先要设计标题和导航的逻辑。顶部的标题栏和底部的导航栏是整个App的外框，其他页面都在中间的位置来加载。当加载第二级页面的时候，再将导航栏和标题栏覆盖。上面描述的就是整个App的外框结构。 标题栏使用mui框架自带的mHeader组件，我们使用css对其进行适当改造。 .xt-title{ position: fixed; width: 100%; background-color: #FF9800; height: 55px; z-index: 1000000; } .xt-title>h1{ color: white; height: 55px; line-height: 55px; font-size: 20px; text-align: center; } .xt-title>a{ color: white; height: 55px; line-height: 55px; display: flex; flex-direction: column; justify-content: center; } 实现的效果是 在描述导航栏的逻辑之前，需要先讲到Vue.js框架，因为我们需要使用vue来渲染导航栏的内容和导航栏的点击事件。 在vue的data中，需要存放如下几个数据对象 //刚进入页面要加载的webview urls: [ { title: '一个像美团一样的点餐App', url: 'mine.html', display: 'none' }, { title: '点餐', url: 'storeList.html', display: '' } ], webviews:[], //当前webview currentIFrame: 0 在页面加载完成事件mounted中，除了检查token之外，还需要加载一系列的webview。需要加载的webview列表就是data.urls数组。在App启动的时候，先加载好需要显示的页面，在点击导航栏的时候只需要控制是否显示。如果是点击导航栏才加载页面，会导致卡顿，体验极差。 对加载webview的实现方式是 var _this = this; for(var i in _this.urls){ var C = plus.webview.create(_this.urls[i].url,_this.urls[i].url,{ top: '55px', bottom: '50px' }); plus.webview.currentWebview().append(C); } plus.webview.getWebviewById(_this.urls[_this.currentIFrame].url).show(); 在methods对象中有这样一个方法，用来切换导航。 switchPage(index){ var _this = this; for(var i in _this.urls){ plus.webview.getWebviewById(_this.urls[i].url).hide(); } plus.webview.getWebviewById(_this.urls[index].url).show(); _this.currentIFrame = index; } 将这个方法绑定到每个导航按钮上，就可以实现导航栏切换页面了。例如 首页 上述逻辑与页面都完成后，进入App的页面如下。 搭建好了导航和标题之后，所有一级页面都只需要嵌在这个外框中即可。需要二级页面的时候，使用5+提供的plus.webview接口即可创建新的webview，覆盖在外框上即可。 6.3.3 用户首页和订单列表 用户首页的实现结果如上图所示，这个页面分为个人信息和订单列表两个部分。两部分的数据分别使用ajax获取。每个需要绑定的数据项都写在vue的data中，在ajax之后将数据对应存入即可。 vue的data对象初始状态是 morning: '..好', icon: '', nickname: '...', restMoney: '...', orderList: [] 获取用户信息的逻辑是 getUserInfo(){ var _this = this; ajax('user',{ token: plus.storage.getItem('token'), method: 'getUserInfo', field: 'nickname,icon,restMoney' },function(res){ vd(res); if(res.code == 0){ _this.restMoney = res.data.restMoney; _this.nickname = res.data.nickname; _this.icon = res.data.icon == null?null:{'background-image':'url('+ res.data.icon +')'}; }else{ alert(res.msg); } }); } 获取订单列表的逻辑是 getOrderList(){ var _this = this; ajax('order',{ method: 'listMyOrder', token: plus.storage.getItem('token') },function(res){ if(res.code == 0){ var orderList = []; for(var i in res.data){ res.data[i].goodName = res.data[i].goods[0].name; orderList.push(res.data[i]); } _this.orderList = orderList; }else{ alert(res.msg); } }); } 在页面加载事件mounted中，需要启动上面两个逻辑。 this.getUserInfo(); this.getOrderList(); 这样就获取到了页面初始化的数据。 点击订单项时需要跳转到订单详情，需要向订单详情页传入订单id。订单列表项的@click事件是 对应的jumpToDetailPage逻辑是 jumpToDetailPage(orderId){ plus.webview.create('orderDetail.html','orderDetail.html',{},{ orderId: orderId }).show('slide-in-right'); } 稍后在订单详情页的描述中会讲述如何获取这个orderId。 6.3.4 店铺列表 店铺列表的获取方式与订单列表的获取方式相同，使用ajax获取数据，放在vue的data中，使用vue渲染到页面上。实现结果是 6.3.5 店铺详情和物品列表 店铺详情和物品列表在同一个页面中，使用两个接口分别获取。店铺详情包括店铺名称和店铺简介。获取到的商品列表要可以选择数量，从而直接创建订单。 由于对每个商品都要选择数量，所以商品列表的data对象和之前的列表都不同，首先我们先看获取商品列表的逻辑。 getGoodsList(){ var _this = this; ajax('goods',{ method: 'listGoods', shopId: _this.shopId, },function(res){ if(res.code == 0){ for(var i in res.data){ _this.goodList.push({ goodId: res.data[i].id, name: res.data[i].name, descr: res.data[i].describe, price: (res.data[i].newPrice == null)?res.data[i].price:res.data[i].newPrice, oriPrice: res.data[i].price, wantCount: 0 }); } console.log(JSON.stringify(_this.goodList)) }else{ alert('获取物品列表时出现错误：' + res.msg); } }); } price和oriPrice是原价和现价，显示在页面上是为了有划线价格的效果。wantCount是想要的数量，用于实现点餐效果。 页面被渲染之前的样子是 商品选择的加减号的样式是 - + 点击减号会减少对应的数量，点击加号会增加对应的数量，加减的逻辑实现方式是 wantMore(goodId){ this.goodList[goodId].wantCount ++; plus.nativeUI.toast(this.goodList[goodId].name + '，' + this.goodList[goodId].descr); } wantLess(goodId){ if(this.goodList[goodId].wantCount != 0){ this.goodList[goodId].wantCount --; plus.nativeUI.toast('你失去了' + this.goodList[goodId].descr); } } 点击结账之后会将物品列表和想要的数量整理为一个json字符串，传入创建订单页面。页面跳转逻辑是 plus.webview.create('createOrder.html','createOrder.html',{},{ goodList: JSON.stringify(_this.goodList) }).show('slide-in-right'); 6.3.6 创建订单 创建订单页面初始化成功后，会获取上一个webview传入的物品列表和价格信息并显示给用户。同时获取当前用户保存的地址信息，并可以选择其他地址。创建订单页面的实现结果是 由于全部商品数和金额总数需要通过计算商品列表的价格来得出，所以这个页面需要用到vue的computed属性。计算total的逻辑是 computed: { total(){ var _this = this; var _total = { count: 0, money: 0 }; for(var i in _this.goodList){ if(_this.goodList[i].wantCount > 0){ _total.count += _this.goodList[i].wantCount; _total.money += _this.goodList[i].wantCount * _this.goodList[i].price; } } return _total; } } 由于下单按钮在屏幕底部，会挡到商品列表，所以当商品列表满一页的时候，下单按钮的一条会整体上移。这个逻辑的实现方式是 window.onscroll = function(e){ var a = document.documentElement.scrollTop || document.body.scrollTop;//滚动条y轴上的距离 var c = document.getElementById('total'); if(a > 320){ c.style.removeProperty('bottom'); c.style.top = '66px'; }else if(a 当点击下单，会将物品列表整理成后端接口所规定的格式，通过ajax的方式发送到后端。 createOrder(){ var _this = this; var goodsIdArr = []; for(var i = 0; i 0){ goodsIdArr.push(_this.goodList[i].goodId); } } var goodsIdStr = goodsIdArr.join(','); ajax('order',{ method: 'createOrder', token: plus.storage.getItem('token'), goodsList: goodsIdStr, name: _this.addr.name, phone: _this.addr.phone, addr: _this.addr.addr },function(res){ if(res.code == 0){ alert('下单成功，已自动扣款。请返回首页查看订单。'); plus.webview.getWebviewById('storeHomePage.html').close(); plus.webview.currentWebview().close(); }else{ alert(res.msg); } }); } 6.3.7 用户信息修改 用户修改信息只支持修改头像和昵称，当想要修改其他字段内容的时候，系统会给出提示。修改用户信息的逻辑实现是 updateUserinfo(key){ var _this = this; if(key == 'nickname'){ var newNickname = prompt('请输入新的昵称'); if(newNickname){ ajax('user',{ token: plus.storage.getItem('token'), method: 'setUserInfo', key: 'nickname', value: newNickname },function(res){ if(res.code == 0){ alert('修改昵称成功'); _this.nickname = newNickname; plus.webview.getLaunchWebview().reload(); }else{ alert(res.msg); } }); } }else if(key == 'icon'){ document.getElementById('imageChoose').click(); document.getElementById('imageChoose').addEventListener('change',function(e){ var form = new FormData(); form.append('file',document.getElementById('imageChoose').files[0]); var xhr = new XMLHttpRequest(); xhr.open(\"post\", 'http://xtzero.me/dressupAsMeituan/api/upload.php?method=uploadImage', true); xhr.onload = function(res){ //这个值就是ajax返回的数据 var xxx = JSON.parse(res.currentTarget.response); if(xxx.code == 0){ var imageUrl = 'http://xtzero.me/dressupAsMeituan/api/' + xxx.data.filename; ajax('user',{ token: plus.storage.getItem('token'), method: 'setUserInfo', key: 'icon', value: imageUrl },function(res){ if(res.code == 0){ alert('修改头像成功'); plus.webview.getLaunchWebview().reload(); plus.webview.currentWebview().reload(); }else{ alert(res.msg); } }); }else{ alert(xxx.msg) } } xhr.onerror = function(){ alert('上传失败，请稍后重试'); } xhr.send(form); }) }else{ alert('这项不提供修改'); } 当要修改的信息是头像时，会调用系统的文件选择器来让用户选择头像。选择图片之后会通过接口将图片传到服务器，并将返回的地址发送给修改用户信息接口。 6.3.8 订单详情 打开订单详情页时，会先使用 var orderId = plus.webview.currentWebview().orderId; 来从上一个页面获取传入的订单id。如果判断没有订单id，则会提示错误。 if(orderId){ _this.orderId = orderId; }else{ alert('没有订单id，请从上一个页面重新跳转') } 订单详情页会获取订单的收货地址信息和物品列表信息。total仍然是使用vue的computed计算属性来处理。 computed: { total(){ var _this = this; return { count: _this.goodList.length, money: (function(){ var sum = 0.0; for(var i = 0; i 6.3.9 收货地址选择和管理 收货地址的管理功能出现在创建订单页面和个人信息页面，两个入口跳转的都是收货地址管理页面。收货地址页面的实现结果是 进入页面需要从接口获取已经存在的地址列表。点击添加地址时会提示用户输入收货人名字、收货地址、收货人电话。其中，填写收货地址时可以选择是否到店吃。如果是到店吃，前端会向后端传入一个约定好的字符串eat_in_shop。相对地，获取列表时如果判断收货地址是这个字符串，也要进行相对的处理，显示到店吃字样。 "},"md/6.4.html":{"url":"md/6.4.html","title":"6.4 后台管理端前端页面与逻辑","keywords":"","body":"6.4 后台管理端前端页面与逻辑 后台管理端和App端使用完全不一样的前端架构，但是实现的业务逻辑都大同小异。所以我们需要使用另一套技术架构来实现这部分的需求。 后台管理端使用vue-cli工具开发，前端页面完全组件化。使用vue-cli + webpack + bable打包生成发布版代码，可以兼容全平台。 6.4.1 登录机制 和App端相似，通过登录接口获取到的登录凭证也需要保存到本地。浏览器环境下也有类似5+环境中的plus.storage，我们可以使用localStorage来保存这些内容。在登录页面的逻辑中可以看到 this.$ajax('account', { method: 'login', usr: this.username, pwd: this.password }, function(res){ console.log(res); if (res.code == 0) { for(var i in res.data){ localStorage.setItem(i, res.data[i]); } window.location.hash = '/'; } else { alert(res.msg); } }); 这样的代码。这段代码将登录接口获取到的凭证存入了本地存储。 6.4.2 导航和路由 框架自带的导航功能可以满足当前项目的全部需求，在/_nav.js中导航是这样定义的 export default { items: [ { name: '首页', url: '/home', icon: 'icon-speedometer', }, { name: '订单管理', url: '/order', icon: 'icon-speedometer', }, { name: '店铺管理', url: '/shop', icon: 'icon-speedometer', }, { name: '物品管理', url: '/goods', icon: 'icon-speedometer', }, { name: '用户管理', url: '/user', icon: 'icon-speedometer', }, ] } 这样规定好了导航，在页面上会显示为 点击每个导航，页面会跳转到url规定的路由上。在vue项目中，路由不是普通的页面跳转，而是使用了url中的锚点功能。例如上面的首页对应的url是 http://host/#/home 我们知道，在url中的锚点以#分割，#后边是锚点值，通常用于与a标签配合使用，用于跳转到页面的指定位置。vue将这个特性封装成了路由，使用跳转到某个锚点的功能实现页面跳转。路由的具体原理不用深究，实现即可。 路由规定在/router/index.js文件中。 import Vue from 'vue' import Router from 'vue-router' const homepage = () => import('@/views/a/home.vue'); const order = () => import('@/views/a/order.vue'); const login = () => import('@/views/a/Login.vue'); const shop = () => import('@/views/a/shop.vue'); const goods = () => import('@/views/a/goods.vue'); const user = () => import('@/views/a/user.vue'); Vue.use(Router) export default new Router({ mode: 'hash', // https://router.vuejs.org/api/#mode linkActiveClass: 'open active', scrollBehavior: () => ({y: 0}), routes: [ { path: '/', redirect: '/home', name: '', component: DefaultContainer, children: [ { path: 'home', name: '首页', component: homepage }, { path: 'shop', name: '店铺管理', component: shop, }, { path: 'order', name: '订单管理', component: order }, { path: 'goods', name: '物品管理', component: goods }, { path: 'user', name: '用户管理', component: user } ] }, { path: '/login', name: '', component: login, } ] }) 用这个方式规定好了路由功能，在框架种还可以根据路由的name字段值来生成面包屑。例如 上图中顶部的“用户管理”就是面包屑，当产生层级关系时，面包屑还有跳转功能。 只有在路由中规定好的页面路径，点击导航时才会加载对应的vue模板。 6.4.3 订单管理 订单管理使用表格功能实现，vue模板是 订单id 物品 订餐人 价格 电话 地址 v.id 等 / 进入页面会加载订单列表，载入订单列表的接口访问逻辑是 listShop() { this.$ajax('order', { method: 'orderList', token: window.localStorage.getItem('token') }, (res) => { console.log(res); if (res.code == 0) { this.list = []; for (var i in res.data) { this.list.push(res.data[i]); } } else { alert(res.msg); } }); } 加载好了数据会放在vue的data对象中，并循环渲染到页面上。页面加载完毕的效果是 6.4.4 店铺管理 进入店铺管理页面会加载店铺列表 listShop() { this.$ajax('shop', { method: 'listShop', token: window.localStorage.getItem('token') }, (res) => { console.log(res); if (res.code == 0) { this.list = []; for (var i in res.data) { this.list.push(res.data[i]); } } else { alert(res.msg); } }); } 加载店铺列表的同时为每个字段绑定修改功能，并且提供对单条数据的操作功能。页面渲染部分的实现是 店铺id 店铺名称 店铺简介 操作 删除店铺 在后台管理系统，提供添加店铺的功能。添加店铺时，我们引用了框架的b-form组件，来显示一个人性化的输入表单。 店铺管理页面加载完成的效果是 6.4.5 物品管理 物品管理和店铺管理的页面逻辑大同小异，也是获取列表再提供修改功能。实现效果是 后台管理系统提供添加物品的功能。添加物品时，所属店铺需要从已经存在的店铺列表中获取。 6.4.6 用户管理 用户管理页面会获取当前系统中存在的全部用户的列表，并且提供所有字段包括用户余额的修改权限。 "},"md/7.html":{"url":"md/7.html","title":"第7章 软件测试","keywords":"","body":"第7章 软件测试 由于这个项目从设计到开发都是一个人完成，所以在开发的同时也在进行同步的测试。所以程序开发过程中，已经排除了致命bug。所以在测试这一章，我们只提供简短的测试报告。 7.1 功能测试 功能测试我们主要从四个方面进行评估，这四个方面分别是适用性、准确性、可操作性、安全性。 适用性方面，我们的目标用户是对自家店铺有线上运营需求的商家，为商家提供数据和交流平台。从适用性进行评估，一定是优良的。 准确性方面，程序每一个元素都具有准确的意义，文案上都会给用户以精准的引导。用户在使用程序的时候不会因为用户界面或操作指引而产生模棱两可的认知。而且每一个功能模块相对独立，且具有相对明确的功能。准确性是可行的。 可操作性方面，本应用为用户提供了近15 个功能点，其中包含三个信息流形态的功能（订单列表，物品列表，店铺列表），足以让用户进行流畅的操作。 安全性上，我们对用户数据绝对保密，而且在技术上使用https 双向加密协议，使用token机制保护用户的私密信息。密码保存上使用了md5 加密技术，由于使用了双层md5 加密方法，可以使我们的安全级别更上一层楼。 测试内容 结果 适用性 好 准确性 好 可操作性 好 安全性 好 表：功能性测试报告 7.2 可用性测试 可用性测试用于评估此应用对用户而言的友好程度，我们将从用户的角度进行可用性的评价。 由于HBuilder底座封装好了一系列的底层接口，所以用户体验上一定是最接近原生app的。每个模块都是独立的功能，模块间耦合很低。对于可操作的模块，界面设计都很友好，并且都有很明显的引导内容。 得益于基于mui和vue的前端框架，数据得以更好地展示。采用双向绑定技术，循环渲染出来的页面是HTML 循环渲染DOM 结构方式的几倍效率。程序在关键位置都加以简介的文字说明，而且计划在关于页面增加帮助 手册，可以帮助用户更容易地使用此程序。 测试内容 测试结果 操作模块是否友好 友好 文字提示、操作引导是否合理 合理 数据项能否正常显示 能 操作流程是否合理 是 是否提供了帮助信息 是 表：可用性测试报告 7.3 测试结果分析 在编写代码过程中，已经对致命性缺陷进行排除，但由于vue方面的经验不足，写代码的过程中依然造成了许多缺陷。在反复地调试之后，将前后端成功地组装在了一起，完成了整个系统的编码开发。 经过编码调试、功能测试、可用性测试，此程序可以满足用户的需求和要求，所有基本功能齐全，操作简单且友好，系统性能优良，可以完美运行于任何终端。 "},"md/n1.html":{"url":"md/n1.html","title":"结论","keywords":"","body":"结论 本文档使用团队中项目实际开发的顺序，对整个设计、实施、测试流程进行了详细的叙述，向用户展现商家线上运营的趋势。 商家进行线上运营是未来商家们的趋势，这种线上与线下搭配的运营方式，所能达到的效率和营收都是传统的方式所做不到的。这种运营方式增加了开发成本，但是节约了服务员的人力，如果系统完善，甚至可以不需要服务员。 在这个信息爆炸的时代，人们都将自己挂在手机上，追求着无止境的娱乐。殊不知手机可以为生活提供巨大的便利。在娱乐至上的时代，人们更需要一个可以满足一定需求的工具来使生活更加便利。我们借助一定的技术，为商家搭建了一个在线运营的平台，并为商家提供一定的便利服务与数据服务，完全满足了商家的需求。 "},"md/n2.html":{"url":"md/n2.html","title":"参考文献","keywords":"","body":"参考文献 [1] Guillaume Chau．Vue:渐进式JavaScript 框架〔OL〕．https://cn.vuejs.org/，. [2] ．Vue cli〔OL〕．https://cli.vuejs.org/zh/guide/cli-service.html，. [3] 数字天堂．MUI-最接近原生App体验的前端框架〔OL〕．http://www.dcloud.io/mui.html，. [4] （美）赞德斯彻.深入PHP：面向对象、模式与实践(第3版)[M].人民邮电出版社,2011.7 [5] 杨宇.PHP典型模块与项目实战大全[M].清华大学出版社,2012.1 [6]W.Jason.PHP与MySQL程序设计 [M]. 北京：人民邮电出版社， 2009 [7]王珊，萨师煊.数据库系统概论[M].北京：高等教育出版社，2009 "},"md/n3.html":{"url":"md/n3.html","title":"后记","keywords":"","body":"后记 后记随便编吧，或者直接去掉。 "}}